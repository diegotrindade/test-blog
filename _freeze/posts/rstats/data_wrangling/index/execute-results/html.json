{
  "hash": "fe14cad7e2d5ca0dccbb4c94597d657a",
  "result": {
    "markdown": "---\ntitle: \"#1 Data wrangling in ecology with `tidyverse`\"\nauthor: Diego P.F. Trindade\ndate: '2020-07-15'\nslug: data-wrangling-in-ecology\nhtml:\n    fig-width: 8\n    fig-height: 8\nexecute:\n  echo: true\n  warning: false\n  message: false\ncategories: []\ntags:\n  - bigdata\n  - ecology\n  - tidyverse\n  - data wrangling\nimage: \"featured.png\"\n---\n\n\n![Image credit: Alisson Horst](featured.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages(c(\"here\", \"dplyr\", \"vroom\", \"tidyr\", \"purrr\"))\nlibrary(here)\nlibrary(dplyr)\nlibrary(vroom)\nlibrary(tidyr)\nlibrary(purrr)\n```\n:::\n\n\n\n\nThe amount of data becoming available in ecology has been increasing rather fast in the recent years. Therefore, being able to wrangling, analyzing and visualizing this data, associated with a good scientific question, is timely for ecologists. Here, I will introduce some `tidyverse` packages and functions that can make this part of the job a bit easier.\n\nMost information I will present here was gotten from our outstanding R community ([StackOverflow](https://stackoverflow.com), [GitHub](https://github.com), [Twitter posts - #rstats -](https://twitter.com/search?q=%23rstats&src=typed_query&f=live) and R books), based on daily issues faced during my PhD. Also, everything here can be achieved by using base R. However, some `tidyverse` packages can be helpful to avoid unnecessary loops and functions, saving some lines of code and time. The intention of this post is, therefore, to show some useful functions that can facilitate our life but also to gather information in one place for my own purpose :).\n\nIn this post, I will be using the **BioTime** database as an example, which is a biodiversity time series data with multiple taxa and several sites around the world (more details at: http://biotime.st-andrews.ac.uk/). I anticipate that this is not an extensive analysis of the data but just an example of how we can use some `tidyverse` packages and functions to any data we want. **Please download both data and metadata, in case you want to follow this post.**\n\nThis post is split into three parts:\n\n-   1st: Presenting `here`, `archive` and `vroom` packages and how to wrangling/exploring data with `dplyr` and `purrr`\n\n-   2nd: Data visualization with `ggplot2` and `cowplot`\n\n-   3rd: Statistical modelling and bootstraps with `tidymodels::broom`\n\n# `here` package\n\nFor those using R projects, `here` is quite handy. With `here` we don't need to set our working directory `(setwd)` anymore. This is particularly interesting whether we are collaborating and have to share our scripts and data with colleagues or need to read files saved at different folders and work on different computers. When using `here` we only need to set the path where the files are saved within the R project:\n\nFor example, let's say the project is in **\"MyFolder\"** and the data in **\"data\"**. Using the traditional way, before starting working on the data, we would have to set up the working directory:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetwd(\"C:\\Users\\yourname\\Desktop\\MyFolder\\data\")\n\nmyfile <- read.csv(\"myfile.csv\")\n```\n:::\n\n\nWith `here`, instead of setting the working directory `(setwd)` and read the file afterwards (`read.csv`), we can go straight to the file part.\n\nFor instance, the project is in **\"MyFolder\"** and we saved your file in **\"data\"**. You can simply read your file as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyfile <- read.csv(here(\"data\", \"myfile.csv\"), header=T, sep=\";\")\n\nor\n\nmyfile <- read.csv(here(\"data\\myfile.csv\", header=T, sep=\";\"))\n```\n:::\n\n\nIf you have a file in a folder within the \"data\" folder you just need to add this new \"path\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyfile2 <- read.csv(here(\"data\", \"differentfolder\", \n                         \"mysecondfile.csv\"), header=T, sep=\";\")\n```\n:::\n\n\nYou can use this for everything you want and it helps to keep files organized within your project. For instance, to save figures, you simply create a new folder to store figures and change the path (i.e. \"data\" by \"figures\"):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggsave(here(\"figures\", file = \"fig1.png\"), fig_object)\n```\n:::\n\n\n# File size\n\nSpecially if you are storing your projects on GitHub, large files can be annoying, since GitHub allows us to store files up to 100 mb. To tackle this issue, we can either use the lfs storage method (more details at: https://git-lfs.github.com) or compress the data as `.zip` or `.gz` files. Sometimes, though, the file is too large that even after compressing it, you still need to use the lsf method to push it to GitHub - which is the biotime case. Anyway, it is good to know how to compress your files in case you need it for a different data.\n\nThere are different ways to do that in R. I'm going to use here the `archive` package. This package is a good alternative for both compressing and reading data.\n\nAs the biotime file is already zipped, let's use the metadata as an example.\n\nFirst we read the file\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmetadata <- read.csv(here(\"posts\", \"rstats\", \n                          \"biotime_meta.csv\"), header=T, sep=\",\") \n```\n:::\n\n\n-   Note that I'm using the path where my project is saved at.\n\nTo compress this file you have to use the `archive_write` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#renv::install(\"archive\")\nlibrary(archive)\nwrite_csv(metadata, archive_write(\"metadata.zip\", \"metadata.csv\"))\n```\n:::\n\n\nI saved the file as *.zip*, but you can use *.gz* or other formats. More information at: https://github.com/jimhester/archive\n\nThe biotime file is already compressed (134 mb). If you extract the .csv, the size will increase to more than 1gb. Working with compressed files can save a lot of time and space when pushing it to GitHub, as I said before.\n\n# `vroom`\n\nIf you don't want to extract the .csv file but read it in the compressed format (e.g. *.zip*, *.gz* etc), there are different ways to do so. I'm going to use the `vroom` package to do the job (faster) - other options would be `readr` package or `fread()` function in `data.table` package.\n\nFor reading the .zip file we simply change from `read.csv`(base R) to `vroom`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#devtools::install_dev(\"vroom\")\nlibrary(vroom)\n\nbiotime_df <- vroom(here(\"posts\", \"rstats\", \n                         \"biotime.zip\"), delim = \",\")\n\nbiotime_metadata <- vroom(here(\"posts\", \"rstats\", \n                               \"biotime_meta.csv\"), delim = \",\")\n```\n:::\n\n\n# Cleaning and exploring BioTime with `dplyr`\n\n`dplyr` is a very useful package to clean and explore data in R. I'm not going to spend much time talking about this package because there are many other great material available out there. Rather, I will just show some important functions, specially for beginner users. You can check a detailed information about this package at: https://dplyr.tidyverse.org\n\nWith `dplyr` we can select and rename columns, filter lines, create new variables and make plenty of cool/complex stuff. Throughout this post, I'm going to use mostly `select`, `filter`, `group_by` and `mutate/summarize`.\n\nLet's start by cleaning both data and metadata using some `dplyr` functions. There are many columns in both files and I'm going to select only those I'm interested in. For that, we can use `select`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbiotime <- biotime_df %>% \n  select(id = STUDY_ID, year = YEAR, plot = PLOT, \n         abundance = sum.allrawdata.ABUNDANCE, \n         biomass = sum.allrawdata.BIOMASS, sp = GENUS_SPECIES)\n\n\nmetadata <- biotime_metadata %>% \n  select(STUDY_ID:ORGANISMS, CENT_LAT, CENT_LONG) %>% \n  rename(id = STUDY_ID)\n```\n:::\n\n\nIf you are not used to dplyr, this `%>%` is called *pipe*, and we can use it to nest our functions. We first select the object we want, then use the `%>%` to nest more functions, separating each one by a new pipe, like I did to create the `metadata` object.\n\nNow, in biotime object, we have species' name, abundance, plot, year and site.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(biotime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n     id  year plot  abundance biomass sp             \n  <dbl> <dbl> <chr>     <dbl>   <dbl> <chr>          \n1    10  1984 12            1       0 Acer rubrum    \n2    10  1984 12            3       0 Acer saccharum \n3    10  1984 12            1       0 Acer spicatum  \n4    10  1984 12           12       0 Corylus cornuta\n5    10  1984 12            1       0 Populus pinnata\n6    10  1984 12           20       0 Acer rubrum    \n```\n:::\n:::\n\n\nWhereas in metadata we have realm, taxa, habitat, whether the area is protected or not etc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(biotime_metadata)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 38\n  STUDY_ID REALM  CLIMATE HABITAT PROTECTED_AREA BIOME_MAP TAXA  ORGANISMS TITLE\n     <dbl> <chr>  <chr>   <chr>   <lgl>          <chr>     <chr> <chr>     <chr>\n1       10 Terre… Temper… Woodla… FALSE          Temperat… Terr… woody pl… Wind…\n2       18 Terre… Temper… Sagebr… FALSE          Deserts … Terr… sagebrus… Mapp…\n3       33 Marine Temper… Seawee… FALSE          Temperat… Mari… phytopla… Long…\n4       39 Terre… Temper… Decidu… FALSE          Temperat… Birds birds     Bird…\n5       41 Terre… Temper… Woodla… FALSE          Temperat… Birds birds     Time…\n6       45 Marine Tropic… Reef    FALSE          Tropical… Fish  tropical… MCR …\n# ℹ 29 more variables: AB_BIO <chr>, HAS_PLOT <chr>, DATA_POINTS <dbl>,\n#   START_YEAR <dbl>, END_YEAR <dbl>, CENT_LAT <dbl>, CENT_LONG <dbl>,\n#   NUMBER_OF_SPECIES <dbl>, NUMBER_OF_SAMPLES <dbl>, NUMBER_LAT_LONG <dbl>,\n#   TOTAL <dbl>, GRAIN_SIZE_TEXT <chr>, GRAIN_SQ_KM <dbl>, AREA_SQ_KM <dbl>,\n#   CONTACT_1 <chr>, CONTACT_2 <chr>, CONT_1_MAIL <chr>, CONT_2_MAIL <chr>,\n#   LICENSE <chr>, WEB_LINK <chr>, DATA_SOURCE <chr>, METHODS <chr>,\n#   SUMMARY_METHODS <chr>, LINK_ID <dbl>, COMMENTS <chr>, …\n```\n:::\n:::\n\n\n-   Note that, in biotime object, I took the opportunity and renamed the columns within `select`. You can also use `rename` if you want (as I did in metadata object). Also, if you have to rename/fix several column names, you can use the [`janitor`](https://github.com/sfirke/janitor) package.\n\nWe use `select` for columns and `filter` for rows. Let´s say we are interested only in *Terrestrial plants* from the metadata. We can go for:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmetadata %>% \nfilter(TAXA == \"Terrestrial plants\") %>% \nhead()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 10\n     id REALM  CLIMATE HABITAT PROTECTED_AREA BIOME_MAP TAXA  ORGANISMS CENT_LAT\n  <dbl> <chr>  <chr>   <chr>   <lgl>          <chr>     <chr> <chr>        <dbl>\n1    10 Terre… Temper… Woodla… FALSE          Temperat… Terr… woody pl…    47.4 \n2    18 Terre… Temper… Sagebr… FALSE          Deserts … Terr… sagebrus…    44.3 \n3    60 Terre… Tropic… Tropic… FALSE          Tropical… Terr… tropical…     9.15\n4   201 Terre… Tropic… Tropic… FALSE          Tropical… Terr… Tropical…     2.98\n5   202 Terre… Tropic… Tropic… FALSE          Tropical… Terr… Tropical…    11.6 \n6   214 Terre… Temper… Conife… FALSE          Temperat… Terr… Trees        45.3 \n# ℹ 1 more variable: CENT_LONG <dbl>\n```\n:::\n:::\n\n\nOf course we can add more arguments to the `filter`, for example, only terrestrial plants in tropical climate and so on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmetadata %>% \nfilter(TAXA == \"Terrestrial plants\",\n       CLIMATE == \"Tropical\") %>% \nhead()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 10\n     id REALM  CLIMATE HABITAT PROTECTED_AREA BIOME_MAP TAXA  ORGANISMS CENT_LAT\n  <dbl> <chr>  <chr>   <chr>   <lgl>          <chr>     <chr> <chr>        <dbl>\n1    60 Terre… Tropic… Tropic… FALSE          Tropical… Terr… tropical…     9.15\n2   201 Terre… Tropic… Tropic… FALSE          Tropical… Terr… Tropical…     2.98\n3   202 Terre… Tropic… Tropic… FALSE          Tropical… Terr… Tropical…    11.6 \n4   241 Terre… Tropic… Tropic… FALSE          Tropical… Terr… Woody pl…     9.36\n5   302 Terre… Tropic… Semi d… TRUE           Tropical… Terr… Trees       -22.4 \n6   322 Terre… Tropic… Semi d… TRUE           Tropical… Terr… Trees       -22.8 \n# ℹ 1 more variable: CENT_LONG <dbl>\n```\n:::\n:::\n\n\nWe can also do the opposite (filter rows out), adding `!` to the column's name:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmetadata %>% \nfilter(!TAXA == \"Terrestrial plants\",\n       !CLIMATE == \"Tropical\") %>% \nhead()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 10\n     id REALM  CLIMATE HABITAT PROTECTED_AREA BIOME_MAP TAXA  ORGANISMS CENT_LAT\n  <dbl> <chr>  <chr>   <chr>   <lgl>          <chr>     <chr> <chr>        <dbl>\n1    33 Marine Temper… Seawee… FALSE          Temperat… Mari… phytopla…     50.2\n2    39 Terre… Temper… Decidu… FALSE          Temperat… Birds birds         43.9\n3    41 Terre… Temper… Woodla… FALSE          Temperat… Birds birds         39.5\n4    46 Terre… Temper… Woodla… FALSE          Temperat… Birds breeding…     51.7\n5    47 Terre… Temper… Ponds   FALSE          Temperat… Birds ducks         50.8\n6    51 Terre… Temper… Woodla… FALSE          Boreal f… Birds tetraoni…     61.9\n# ℹ 1 more variable: CENT_LONG <dbl>\n```\n:::\n:::\n\n\nWe can filter values higher or lower than:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmetadata %>% \nfilter(id > 100) %>% \nhead()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 10\n     id REALM  CLIMATE HABITAT PROTECTED_AREA BIOME_MAP TAXA  ORGANISMS CENT_LAT\n  <dbl> <chr>  <chr>   <chr>   <lgl>          <chr>     <chr> <chr>        <dbl>\n1   108 Marine Global  Oceani… FALSE          Multiple… Birds birds       -27.2 \n2   110 Marine Temper… Estuar… FALSE          Temperat… Bent… Benthos      55.5 \n3   112 Marine Temper… Pelagi… FALSE          Multiple… Fish  pelagic …    25.0 \n4   113 Marine Global  Oceani… FALSE          Multiple… Mari… marine i…     2.70\n5   117 Marine Temper… Tidal … FALSE          Temperat… Mari… Starfish    -39.4 \n6   119 Marine Temper… Pelagi… FALSE          Temperat… Fish  Fish         44.0 \n# ℹ 1 more variable: CENT_LONG <dbl>\n```\n:::\n:::\n\n\nSometimes we need to filter several specific rows. For that, we use `%in%`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmetadata %>% \nfilter(TAXA %in% c(\"Terrestrial plants\",\n                   \"Birds\",\n                   \"Fish\")) %>% \nhead()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 10\n     id REALM  CLIMATE HABITAT PROTECTED_AREA BIOME_MAP TAXA  ORGANISMS CENT_LAT\n  <dbl> <chr>  <chr>   <chr>   <lgl>          <chr>     <chr> <chr>        <dbl>\n1    10 Terre… Temper… Woodla… FALSE          Temperat… Terr… woody pl…     47.4\n2    18 Terre… Temper… Sagebr… FALSE          Deserts … Terr… sagebrus…     44.3\n3    39 Terre… Temper… Decidu… FALSE          Temperat… Birds birds         43.9\n4    41 Terre… Temper… Woodla… FALSE          Temperat… Birds birds         39.5\n5    45 Marine Tropic… Reef    FALSE          Tropical… Fish  tropical…    -17.5\n6    46 Terre… Temper… Woodla… FALSE          Temperat… Birds breeding…     51.7\n# ℹ 1 more variable: CENT_LONG <dbl>\n```\n:::\n:::\n\n\nBesides selecting columns and filtering rows we can also create new columns with `mutate`. Let's filter only the study number 10 and create a new column to check how many species and years they have sampled in this study. We can use `mutate` and `n_distinct()` to achieve that.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbiotime %>% \n  filter(id == 10) %>%\n  mutate(total_sp = n_distinct(sp),\n         total_y = n_distinct(year))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,406 × 8\n      id  year plot  abundance biomass sp                     total_sp total_y\n   <dbl> <dbl> <chr>     <dbl>   <dbl> <chr>                     <int>   <int>\n 1    10  1984 12            1       0 Acer rubrum                  25       3\n 2    10  1984 12            3       0 Acer saccharum               25       3\n 3    10  1984 12            1       0 Acer spicatum                25       3\n 4    10  1984 12           12       0 Corylus cornuta              25       3\n 5    10  1984 12            1       0 Populus pinnata              25       3\n 6    10  1984 12           20       0 Acer rubrum                  25       3\n 7    10  1984 12           14       0 Acer saccharum               25       3\n 8    10  1984 12            1       0 Toxicodendron radicans       25       3\n 9    10  1984 12            5       0 Acer spicatum                25       3\n10    10  1984 12            7       0 Corylus cornuta              25       3\n# ℹ 1,396 more rows\n```\n:::\n:::\n\n\nIn this study we have 25 species and three different years.\n\nNow let's say we want to know how many species we have per year. To get that, we can use the function `group_by`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbiotime %>% \n  filter(id == 10) %>%\n  group_by(year) %>% \n  mutate(total_sp = n_distinct(sp))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,406 × 7\n# Groups:   year [3]\n      id  year plot  abundance biomass sp                     total_sp\n   <dbl> <dbl> <chr>     <dbl>   <dbl> <chr>                     <int>\n 1    10  1984 12            1       0 Acer rubrum                  22\n 2    10  1984 12            3       0 Acer saccharum               22\n 3    10  1984 12            1       0 Acer spicatum                22\n 4    10  1984 12           12       0 Corylus cornuta              22\n 5    10  1984 12            1       0 Populus pinnata              22\n 6    10  1984 12           20       0 Acer rubrum                  22\n 7    10  1984 12           14       0 Acer saccharum               22\n 8    10  1984 12            1       0 Toxicodendron radicans       22\n 9    10  1984 12            5       0 Acer spicatum                22\n10    10  1984 12            7       0 Corylus cornuta              22\n# ℹ 1,396 more rows\n```\n:::\n:::\n\n\nWe can see that we have 22 species in 1984, 20 species in 1992, we can't see the third year though. That's because `mutate` creates a new column and repeats the values for each row we have. To get a summarized overview, we can use `summarise` instead.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbiotime %>% \n  filter(id == 10) %>%\n  group_by(year) %>% \n  summarise(total_sp = n_distinct(sp))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n   year total_sp\n  <dbl>    <int>\n1  1984       22\n2  1992       20\n3  1996       20\n```\n:::\n:::\n\n\nNow we can see the number of species per year, but the other columns were deleted. Therefore, both mutate and summaries give us the same result but in different ways, you have to choose which one fits better your purpose when dealing with the data.\n\nWe can also combine `summarise` and `mutate` to get, for example, the frequency of species\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbiotime %>%\n  filter(id == 10) %>%\n  group_by(sp) %>% \n  summarise (total = n()) %>%\n  mutate(freq = total / sum(total))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 × 3\n   sp                  total     freq\n   <chr>               <int>    <dbl>\n 1 Acer rubrum           185 0.132   \n 2 Acer saccharum        290 0.206   \n 3 Acer spicatum         146 0.104   \n 4 Amelanchier gravida     1 0.000711\n 5 Amelanchier laevis     30 0.0213  \n 6 Betula papyrifera      10 0.00711 \n 7 Cornus racemosa         6 0.00427 \n 8 Cornus rugosa          35 0.0249  \n 9 Corylus cornuta       244 0.174   \n10 Diervilla lonicera     14 0.00996 \n# ℹ 15 more rows\n```\n:::\n:::\n\n\nNote that I've grouped by \"species\". We could also check the frequency of each species per year, adding the variable \"year\" in `group_by()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbiotime %>% \n  filter(id == 10) %>%\n  group_by(sp,year) %>% \n  summarise (total = n()) %>%\n  mutate(freq = total / sum(total))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 62 × 4\n# Groups:   sp [25]\n   sp                   year total  freq\n   <chr>               <dbl> <int> <dbl>\n 1 Acer rubrum          1984    77 0.416\n 2 Acer rubrum          1992    68 0.368\n 3 Acer rubrum          1996    40 0.216\n 4 Acer saccharum       1984   105 0.362\n 5 Acer saccharum       1992   109 0.376\n 6 Acer saccharum       1996    76 0.262\n 7 Acer spicatum        1984    62 0.425\n 8 Acer spicatum        1992    55 0.377\n 9 Acer spicatum        1996    29 0.199\n10 Amelanchier gravida  1984     1 1    \n# ℹ 52 more rows\n```\n:::\n:::\n\n\n# `tidyr` - the art of pivoting data\n\nAs ecologists, we have to deal with data frames either in long or wide formats all the time. Knowing how to transform the data into both formats, in R, is very handy and safe, because we don't need to create several .csv files, maintaining the original data intact, decreasing the chances of messing up it.\n\nThe most important functions to transform data frames in `tidy` are `pivot_longer()` and `pivot_wider()`. These functions have been improved constantly. Out there, you will find `reshape2` package, `melt`, `spread` and `gather`. Those are the old school functions to transform data frames. I'm slowly moving from `spread`/`gather` into `pivot_wider()`/`pivot_longer()`. Then, let's try to transform our data into both wide and long formats using the new functions.\n\nLet's use the same example (study id 10) to transform the data into the wide format. We use `pivot_wider()`, specifying that the species names present in \"sp\" column will be the columns of the new object (`names_from = \"sp\"`) and the values present in \"abundance\" will be the row values (`values_from = \"abundance\"`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbiotime %>% \n  filter(id == 10) %>%\n  pivot_wider(names_from = \"sp\", values_from = \"abundance\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 47 × 29\n      id  year plot  biomass `Acer rubrum` `Acer saccharum` `Acer spicatum`\n   <dbl> <dbl> <chr>   <dbl> <list>        <list>           <list>         \n 1    10  1984 12          0 <dbl [4]>     <dbl [3]>        <dbl [2]>      \n 2    10  1984 1           0 <dbl [4]>     <dbl [4]>        <dbl [4]>      \n 3    10  1984 2           0 <dbl [4]>     <dbl [8]>        <dbl [8]>      \n 4    10  1984 34          0 <dbl [4]>     <dbl [6]>        <dbl [8]>      \n 5    10  1984 35          0 <dbl [4]>     <dbl [10]>       <dbl [5]>      \n 6    10  1984 36          0 <dbl [4]>     <dbl [8]>        <NULL>         \n 7    10  1984 37          0 <dbl [3]>     <dbl [10]>       <NULL>         \n 8    10  1984 38          0 <dbl [4]>     <dbl [6]>        <NULL>         \n 9    10  1984 39          0 <dbl [3]>     <dbl [4]>        <NULL>         \n10    10  1984 40          0 <dbl [2]>     <dbl [2]>        <dbl [6]>      \n# ℹ 37 more rows\n# ℹ 22 more variables: `Corylus cornuta` <list>, `Populus pinnata` <list>,\n#   `Toxicodendron radicans` <list>, `Diervilla lonicera` <list>,\n#   `Populus sp` <list>, `Cornus rugosa` <list>, `Prunus virginiana` <list>,\n#   `Rubus flagellaris` <list>, `Viburnum rafinesquianum` <list>,\n#   `Quercus rubra` <list>, `Vaccinium angustifolium` <list>,\n#   `Pinus strobus` <list>, `Ostrya virginiana` <list>, …\n```\n:::\n:::\n\n\nOops.. something went wrong. It transformed our data frame but in an odd way. The warning says that our data is not uniquely identified, meaning that the function can't recognize each row, separately, in our data frame. To tackle this issue, we can simply bring the row names to a column, identifying each row, with the function `rownames_to_column()`. Let´s try again.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbiotime %>% \n  filter(id == 10) %>%\n  rownames_to_column() %>% \n  pivot_wider(names_from = \"sp\", values_from = \"abundance\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,406 × 30\n   rowname    id  year plot  biomass `Acer rubrum` `Acer saccharum`\n   <chr>   <dbl> <dbl> <chr>   <dbl>         <dbl>            <dbl>\n 1 1          10  1984 12          0             1               NA\n 2 2          10  1984 12          0            NA                3\n 3 3          10  1984 12          0            NA               NA\n 4 4          10  1984 12          0            NA               NA\n 5 5          10  1984 12          0            NA               NA\n 6 6          10  1984 12          0            20               NA\n 7 7          10  1984 12          0            NA               14\n 8 8          10  1984 12          0            NA               NA\n 9 9          10  1984 12          0            NA               NA\n10 10         10  1984 12          0            NA               NA\n# ℹ 1,396 more rows\n# ℹ 23 more variables: `Acer spicatum` <dbl>, `Corylus cornuta` <dbl>,\n#   `Populus pinnata` <dbl>, `Toxicodendron radicans` <dbl>,\n#   `Diervilla lonicera` <dbl>, `Populus sp` <dbl>, `Cornus rugosa` <dbl>,\n#   `Prunus virginiana` <dbl>, `Rubus flagellaris` <dbl>,\n#   `Viburnum rafinesquianum` <dbl>, `Quercus rubra` <dbl>,\n#   `Vaccinium angustifolium` <dbl>, `Pinus strobus` <dbl>, …\n```\n:::\n:::\n\n\nOk. It seems we are getting closer. Now we have the study 10 data frame in the wide format but when the species is absent we have NA's. To tackle this, we add the argument `values_fill` to our `pivot_wider()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbiotime %>% \n  filter(id == 10) %>%\n  rownames_to_column() %>% \n  pivot_wider(names_from = \"sp\", values_from = \"abundance\", \n              values_fill = list(abundance=0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,406 × 30\n   rowname    id  year plot  biomass `Acer rubrum` `Acer saccharum`\n   <chr>   <dbl> <dbl> <chr>   <dbl>         <dbl>            <dbl>\n 1 1          10  1984 12          0             1                0\n 2 2          10  1984 12          0             0                3\n 3 3          10  1984 12          0             0                0\n 4 4          10  1984 12          0             0                0\n 5 5          10  1984 12          0             0                0\n 6 6          10  1984 12          0            20                0\n 7 7          10  1984 12          0             0               14\n 8 8          10  1984 12          0             0                0\n 9 9          10  1984 12          0             0                0\n10 10         10  1984 12          0             0                0\n# ℹ 1,396 more rows\n# ℹ 23 more variables: `Acer spicatum` <dbl>, `Corylus cornuta` <dbl>,\n#   `Populus pinnata` <dbl>, `Toxicodendron radicans` <dbl>,\n#   `Diervilla lonicera` <dbl>, `Populus sp` <dbl>, `Cornus rugosa` <dbl>,\n#   `Prunus virginiana` <dbl>, `Rubus flagellaris` <dbl>,\n#   `Viburnum rafinesquianum` <dbl>, `Quercus rubra` <dbl>,\n#   `Vaccinium angustifolium` <dbl>, `Pinus strobus` <dbl>, …\n```\n:::\n:::\n\n\nNow we have the data transformed into the wide format, with 0's instead of NA's. Note that, sometimes, the row names are names instead of numbers (i.e. sometimes we use species names as row names). If you face that, you can create a new column, labeling the rows, using `mutate()` and `row_number()` instead of `rownames_to_column()`. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbiotime_wider <- biotime %>% \n  filter(id == 10) %>%\n  #rownames_to_column() %>% \n  mutate(id_rows = row_number()) %>% \n  pivot_wider(names_from = \"sp\", values_from = \"abundance\", values_fill = list(abundance=0))\n```\n:::\n\n\nNow let´s transform our data into the other way round, from wide into long format. For that, we can use the function `pivot_longer()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbiotime_wider %>% \n  pivot_longer(names_to = \"sp\", values_to = \"abundance\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `pivot_longer()`:\n! `cols` must select at least one column.\n```\n:::\n:::\n\n\nError. When pivoting longer, we have to pay attention to the other columns we may have. In the `biotime_wider` object we have `id`, `year`, `plot`, `biomass`, `id_rows` and `species names`. We want to transform only `species names` and `values` (abundance) though. In this case, we have to omit the other columns we don't want to transform.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbiotime_wider %>% \n  pivot_longer(-c(id:id_rows),names_to = \"sp\", values_to = \"abundance\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 35,150 × 7\n      id  year plot  biomass id_rows sp                     abundance\n   <dbl> <dbl> <chr>   <dbl>   <int> <chr>                      <dbl>\n 1    10  1984 12          0       1 Acer rubrum                    1\n 2    10  1984 12          0       1 Acer saccharum                 0\n 3    10  1984 12          0       1 Acer spicatum                  0\n 4    10  1984 12          0       1 Corylus cornuta                0\n 5    10  1984 12          0       1 Populus pinnata                0\n 6    10  1984 12          0       1 Toxicodendron radicans         0\n 7    10  1984 12          0       1 Diervilla lonicera             0\n 8    10  1984 12          0       1 Populus sp                     0\n 9    10  1984 12          0       1 Cornus rugosa                  0\n10    10  1984 12          0       1 Prunus virginiana              0\n# ℹ 35,140 more rows\n```\n:::\n:::\n\n\nWith `pivot_longer()` and `pivot_wider()` you can make a lot of more complex transformations, I'm not going to cover those here though, please check them out at: https://tidyr.tidyverse.org/reference/pivot_wider.html\n\n# Merging data and working within lists with `purrr`\n\nNow let´s try to use this knowledge to create more complex objects, using new features, combining functions etc.\n\nWhen analyzing ecological data, most of the time, both data and metadata are useful, like in `BioTime` example.\n\nLet's check both data frames\n\n*BioTime data*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(biotime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n     id  year plot  abundance biomass sp             \n  <dbl> <dbl> <chr>     <dbl>   <dbl> <chr>          \n1    10  1984 12            1       0 Acer rubrum    \n2    10  1984 12            3       0 Acer saccharum \n3    10  1984 12            1       0 Acer spicatum  \n4    10  1984 12           12       0 Corylus cornuta\n5    10  1984 12            1       0 Populus pinnata\n6    10  1984 12           20       0 Acer rubrum    \n```\n:::\n:::\n\n\n*Metadata*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(metadata)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 10\n     id REALM  CLIMATE HABITAT PROTECTED_AREA BIOME_MAP TAXA  ORGANISMS CENT_LAT\n  <dbl> <chr>  <chr>   <chr>   <lgl>          <chr>     <chr> <chr>        <dbl>\n1    10 Terre… Temper… Woodla… FALSE          Temperat… Terr… woody pl…     47.4\n2    18 Terre… Temper… Sagebr… FALSE          Deserts … Terr… sagebrus…     44.3\n3    33 Marine Temper… Seawee… FALSE          Temperat… Mari… phytopla…     50.2\n4    39 Terre… Temper… Decidu… FALSE          Temperat… Birds birds         43.9\n5    41 Terre… Temper… Woodla… FALSE          Temperat… Birds birds         39.5\n6    45 Marine Tropic… Reef    FALSE          Tropical… Fish  tropical…    -17.5\n# ℹ 1 more variable: CENT_LONG <dbl>\n```\n:::\n:::\n\n\nAs you can see, in *biotime* we have `id`, `year`, `plot`, `abundance`, `biomass` and `species`, whereas in *metadata* we have `id`, `realm`, `habitat` etc. So, let's say we are interested in examining terrestrial plants species from tropical forests, but as species are in one data frame and biomes in the other, we first have to merge both data frames. For merging data frames into one we can use either `bind_cols() / bind_rows()` functions, for binding columns and rows, respectively, or the `join family` available in `dplyr` (https://dplyr.tidyverse.org/reference/join.html). Here, we can use the `letf_join()` option to merge both data and metadata.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmerge_df <- left_join(biotime, metadata, by = \"id\")\nhead(merge_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 15\n     id  year plot  abundance biomass sp    REALM CLIMATE HABITAT PROTECTED_AREA\n  <dbl> <dbl> <chr>     <dbl>   <dbl> <chr> <chr> <chr>   <chr>   <lgl>         \n1    10  1984 12            1       0 Acer… Terr… Temper… Woodla… FALSE         \n2    10  1984 12            3       0 Acer… Terr… Temper… Woodla… FALSE         \n3    10  1984 12            1       0 Acer… Terr… Temper… Woodla… FALSE         \n4    10  1984 12           12       0 Cory… Terr… Temper… Woodla… FALSE         \n5    10  1984 12            1       0 Popu… Terr… Temper… Woodla… FALSE         \n6    10  1984 12           20       0 Acer… Terr… Temper… Woodla… FALSE         \n# ℹ 5 more variables: BIOME_MAP <chr>, TAXA <chr>, ORGANISMS <chr>,\n#   CENT_LAT <dbl>, CENT_LONG <dbl>\n```\n:::\n:::\n\n\n`left_join()` merged the data frames based on the study id. This is a safe way to merge data frames because the function will match exactly the same rows present in each data frame based on the argument you give in `\"by = ...\"`; in this case I chose `by = \"id\"`, but depending on your data you can add more variables.\n\nNow we have both data and metadata merged. Then, we can finally check terrestrial plant species from tropical forests.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmerge_df %>% \n  filter(TAXA == \"Terrestrial plants\",\n       CLIMATE == \"Tropical\") %>% \nhead()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 15\n     id  year plot  abundance biomass sp    REALM CLIMATE HABITAT PROTECTED_AREA\n  <dbl> <dbl> <chr>     <dbl>   <dbl> <chr> <chr> <chr>   <chr>   <lgl>         \n1   201  1987 <NA>       2454       0 Aidi… Terr… Tropic… Tropic… FALSE         \n2   201  1987 <NA>         97       0 Fagr… Terr… Tropic… Tropic… FALSE         \n3   201  1987 <NA>        112       0 Fahr… Terr… Tropic… Tropic… FALSE         \n4   201  1987 <NA>         45       0 Ficu… Terr… Tropic… Tropic… FALSE         \n5   201  1987 <NA>       2913       0 Alan… Terr… Tropic… Tropic… FALSE         \n6   201  1987 <NA>          3       0 Ficu… Terr… Tropic… Tropic… FALSE         \n# ℹ 5 more variables: BIOME_MAP <chr>, TAXA <chr>, ORGANISMS <chr>,\n#   CENT_LAT <dbl>, CENT_LONG <dbl>\n```\n:::\n:::\n\n\nor Birds etc\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmerge_df %>% \nfilter(TAXA == \"Birds\",\n       CLIMATE == \"Tropical\") %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 15\n     id  year plot  abundance biomass sp    REALM CLIMATE HABITAT PROTECTED_AREA\n  <dbl> <dbl> <chr>     <dbl>   <dbl> <chr> <chr> <chr>   <chr>   <lgl>         \n1    58  1994 Plot…         2       0 Vire… Terr… Tropic… Long t… FALSE         \n2    58  1991 Plot9         1       0 Paru… Terr… Tropic… Long t… FALSE         \n3    58  1994 Plot…         1       0 Neso… Terr… Tropic… Long t… FALSE         \n4    58  1994 Plot6         7       0 Coer… Terr… Tropic… Long t… FALSE         \n5    58  1991 Plot6         9       0 Neso… Terr… Tropic… Long t… FALSE         \n6    58  1994 Plot6         1       0 Marg… Terr… Tropic… Long t… FALSE         \n# ℹ 5 more variables: BIOME_MAP <chr>, TAXA <chr>, ORGANISMS <chr>,\n#   CENT_LAT <dbl>, CENT_LONG <dbl>\n```\n:::\n:::\n\n\nAlthough those functions are useful to explore big data sets, most of the time, specially when working with multiple variables, filtering each one and examining them separately can be time consuming. For example, let's say we want to transform our current data frame (merge_df) from long into wide format, as we did before. The first time we transformed our data, we had a single study (id=10) and taxa. Now we have multiple studies and taxa. If we try `pivot_wider()`, plant and bird species names, for example, will be assigned as columns, making things difficult to disentangle afterwards. An useful way to avoid this is to split our data frame into lists based on each taxa we have. Then, we can apply the function we want for all elements of that list at once. We can do that using the package `purrr`, which has plenty of functions that make ecologists\\` life a bit easier in that sense. Let's try to understand how this package works.\n\nFirst, let's create different lists based on different taxa with the `split()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsplit_taxa <- merge_df %>% \n             split(.$TAXA)\n\nhead(split_taxa)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$All\n# A tibble: 326,527 × 15\n      id  year plot  abundance biomass sp              REALM  CLIMATE HABITAT   \n   <dbl> <dbl> <chr>     <dbl>   <dbl> <chr>           <chr>  <chr>   <chr>     \n 1   166  1979 <NA>          5       0 Puffinus gravis Marine Global  Oceanic w…\n 2   166  1979 <NA>          2       0 Puffinus gravis Marine Global  Oceanic w…\n 3   166  1979 <NA>         15       0 Puffinus gravis Marine Global  Oceanic w…\n 4   166  1979 <NA>         23       0 Puffinus gravis Marine Global  Oceanic w…\n 5   166  1979 <NA>         20       0 Puffinus gravis Marine Global  Oceanic w…\n 6   166  1979 <NA>         20       0 Puffinus gravis Marine Global  Oceanic w…\n 7   166  1979 <NA>         60       0 Puffinus gravis Marine Global  Oceanic w…\n 8   166  1979 <NA>         16       0 Puffinus gravis Marine Global  Oceanic w…\n 9   166  1979 <NA>          1       0 Puffinus gravis Marine Global  Oceanic w…\n10   166  1979 <NA>        150       0 Puffinus gravis Marine Global  Oceanic w…\n# ℹ 326,517 more rows\n# ℹ 6 more variables: PROTECTED_AREA <lgl>, BIOME_MAP <chr>, TAXA <chr>,\n#   ORGANISMS <chr>, CENT_LAT <dbl>, CENT_LONG <dbl>\n\n$Amphibians\n# A tibble: 2,446 × 15\n      id  year plot  abundance biomass sp                  REALM CLIMATE HABITAT\n   <dbl> <dbl> <chr>     <dbl>   <dbl> <chr>               <chr> <chr>   <chr>  \n 1   305  1980 <NA>         12       0 Desmognathus quadr… Terr… Temper… Appala…\n 2   305  1981 <NA>          4       0 Desmognathus aeneus Terr… Temper… Appala…\n 3   305  1981 <NA>         20       0 Desmognathus monti… Terr… Temper… Appala…\n 4   305  1976 <NA>          8       0 Desmognathus aeneus Terr… Temper… Appala…\n 5   305  1976 <NA>         27       0 Desmognathus monti… Terr… Temper… Appala…\n 6   305  1976 <NA>         15       0 Desmognathus ochro… Terr… Temper… Appala…\n 7   305  1976 <NA>          7       0 Desmognathus quadr… Terr… Temper… Appala…\n 8   305  1977 <NA>          7       0 Desmognathus aeneus Terr… Temper… Appala…\n 9   305  1977 <NA>         22       0 Desmognathus monti… Terr… Temper… Appala…\n10   305  1977 <NA>         18       0 Desmognathus ochro… Terr… Temper… Appala…\n# ℹ 2,436 more rows\n# ℹ 6 more variables: PROTECTED_AREA <lgl>, BIOME_MAP <chr>, TAXA <chr>,\n#   ORGANISMS <chr>, CENT_LAT <dbl>, CENT_LONG <dbl>\n\n$Benthos\n# A tibble: 1,711,785 × 15\n      id  year plot  abundance biomass sp                  REALM CLIMATE HABITAT\n   <dbl> <dbl> <chr>     <dbl>   <dbl> <chr>               <chr> <chr>   <chr>  \n 1    76  1992 <NA>          2       0 Aphroditoidea       Mari… Temper… Estuar…\n 2    76  1992 <NA>          5       0 Ascidiella scabra   Mari… Temper… Estuar…\n 3    76  1992 <NA>          4       0 Asterias rubens     Mari… Temper… Estuar…\n 4    76  1992 <NA>          9       0 Calliostoma zyziph… Mari… Temper… Estuar…\n 5    76  1992 <NA>         10       0 Crepidula fornicata Mari… Temper… Estuar…\n 6    76  1992 <NA>          1       0 Gibbula tumida      Mari… Temper… Estuar…\n 7    76  1992 <NA>          1       0 Hippolyte varians   Mari… Temper… Estuar…\n 8    76  1992 <NA>          1       0 Hyas coarctatus     Mari… Temper… Estuar…\n 9    76  1992 <NA>          1       0 Liocarcinus puber   Mari… Temper… Estuar…\n10    76  1992 <NA>          1       0 Liparis sp          Mari… Temper… Estuar…\n# ℹ 1,711,775 more rows\n# ℹ 6 more variables: PROTECTED_AREA <lgl>, BIOME_MAP <chr>, TAXA <chr>,\n#   ORGANISMS <chr>, CENT_LAT <dbl>, CENT_LONG <dbl>\n\n$Birds\n# A tibble: 1,487,942 × 15\n      id  year plot  abundance biomass sp                  REALM CLIMATE HABITAT\n   <dbl> <dbl> <chr>     <dbl>   <dbl> <chr>               <chr> <chr>   <chr>  \n 1    39  1976 <NA>        7.5      NA Catharus guttatus   Terr… Temper… Decidu…\n 2    39  1976 <NA>        8        NA Catharus ustulatus  Terr… Temper… Decidu…\n 3    39  1976 <NA>       12        NA Dendroica caerules… Terr… Temper… Decidu…\n 4    39  1977 <NA>        2.5      NA Catharus fuscescens Terr… Temper… Decidu…\n 5    39  1977 <NA>        5        NA Catharus guttatus   Terr… Temper… Decidu…\n 6    39  1977 <NA>        7        NA Catharus ustulatus  Terr… Temper… Decidu…\n 7    39  1977 <NA>       11        NA Dendroica caerules… Terr… Temper… Decidu…\n 8    39  1977 <NA>        2        NA Dendroica fusca     Terr… Temper… Decidu…\n 9    39  1977 <NA>       28        NA Empidonax minimus   Terr… Temper… Decidu…\n10    39  1977 <NA>        5        NA Hylocichla musteli… Terr… Temper… Decidu…\n# ℹ 1,487,932 more rows\n# ℹ 6 more variables: PROTECTED_AREA <lgl>, BIOME_MAP <chr>, TAXA <chr>,\n#   ORGANISMS <chr>, CENT_LAT <dbl>, CENT_LONG <dbl>\n\n$Fish\n# A tibble: 2,294,445 × 15\n      id  year plot  abundance biomass sp                  REALM CLIMATE HABITAT\n   <dbl> <dbl> <chr>     <dbl>   <dbl> <chr>               <chr> <chr>   <chr>  \n 1    45  2006 <NA>          1   4.80  Canthigaster solan… Mari… Tropic… Reef   \n 2    45  2006 <NA>          2   0.630 Ctenogobiops feroc… Mari… Tropic… Reef   \n 3    45  2006 <NA>          1  26.8   Echidna nebulosa    Mari… Tropic… Reef   \n 4    45  2006 <NA>          1   1.87  Epinephelus merra   Mari… Tropic… Reef   \n 5    45  2006 <NA>          1   8.31  Paracirrhites arca… Mari… Tropic… Reef   \n 6    45  2006 <NA>          1   0.200 Pseudocheilinus he… Mari… Tropic… Reef   \n 7    45  2006 <NA>         12  70.7   Stegastes nigricans Mari… Tropic… Reef   \n 8    45  2006 <NA>          2  38.7   Acanthurus nigrofu… Mari… Tropic… Reef   \n 9    45  2006 <NA>          1  46.2   Acanthurus trioste… Mari… Tropic… Reef   \n10    45  2006 <NA>          1  18.3   Anampses twistii    Mari… Tropic… Reef   \n# ℹ 2,294,435 more rows\n# ℹ 6 more variables: PROTECTED_AREA <lgl>, BIOME_MAP <chr>, TAXA <chr>,\n#   ORGANISMS <chr>, CENT_LAT <dbl>, CENT_LONG <dbl>\n\n$`Freshwater invertebrates`\n# A tibble: 93,966 × 15\n      id  year plot  abundance biomass sp                  REALM CLIMATE HABITAT\n   <dbl> <dbl> <chr>     <dbl>   <dbl> <chr>               <chr> <chr>   <chr>  \n 1   237  1984 <NA>       2000       0 Daphnia pulicaria   Fres… Temper… Temper…\n 2   237  1983 <NA>      28000       0 Notholca acuminata  Fres… Temper… Temper…\n 3   237  1984 <NA>       8000       0 Keratella quadrata  Fres… Temper… Temper…\n 4   237  1984 <NA>      19000       0 Notholca            Fres… Temper… Temper…\n 5   237  1984 <NA>      11000       0 Synchaeta           Fres… Temper… Temper…\n 6   237  1984 <NA>     768000       0 Conochiloides nata… Fres… Temper… Temper…\n 7   237  1984 <NA>     156000       0 Cyclopoida copepod… Fres… Temper… Temper…\n 8   237  1984 <NA>      16000       0 Daphnia mendotae    Fres… Temper… Temper…\n 9   237  1983 <NA>     194000       0 Copepod nauplii     Fres… Temper… Temper…\n10   237  1983 <NA>       9000       0 Polyarthra dolicho… Fres… Temper… Temper…\n# ℹ 93,956 more rows\n# ℹ 6 more variables: PROTECTED_AREA <lgl>, BIOME_MAP <chr>, TAXA <chr>,\n#   ORGANISMS <chr>, CENT_LAT <dbl>, CENT_LONG <dbl>\n```\n:::\n:::\n\n\nTo work with lists in `purrr` the `map` function will be our loyal servant, and they are many: i.e. `map`, `map2`, `map_dfr`, `map_dfc` etc.\n\n-   `map` is used when we want to apply a function to each element of one list (it works like `lapply`)\n\n-   `map2` is used when we want to apply a function to each element of two lists (it works like `mapply`)\n\n-   `map_dfr` and `map_dfc` are used when we want to combine lists into data frames by rows or columns, respectively.\n\nI will use here `map` and `map2` (specially in data viz and statistical modelling post); if you want to know more, take a look at:\n\nhttps://dcl-prog.stanford.edu/purrr-basics.html\n\nand\n\nhttps://jennybc.github.io/purrr-tutorial/\n\nLet's start with `map()`, filtering studies that have been sampled over more than 10 years.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter_year <- split_taxa %>% map(~ .x %>%\n                                  group_by(id) %>% \n                                  mutate(n_year=n_distinct(year)) %>% # here we create a column showing how many years we have for each taxa, grouped by study id \n                                  filter(n_year > 10)) # and filter only those studies with more than 10 years\n```\n:::\n\n\nIn case you are not used to tidyverse, `map()` works like `lapply()` in base R. Tilda(`~`) represents `function(x)` and `(.)` would be `(x)`. Just to show it, in a very non-sense way, let's sum up the overall number of individuals of each taxa. To make it simple (and even poorer), let's select only the abundance column first.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect_abundance <- filter_year %>% \n  map(~ .x %>% ungroup %>% select(abundance))\n\nhead(select_abundance)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$All\n# A tibble: 313,561 × 1\n   abundance\n       <dbl>\n 1         5\n 2         2\n 3        15\n 4        23\n 5        20\n 6        20\n 7        60\n 8        16\n 9         1\n10       150\n# ℹ 313,551 more rows\n\n$Amphibians\n# A tibble: 327 × 1\n   abundance\n       <dbl>\n 1        12\n 2         4\n 3        20\n 4         8\n 5        27\n 6        15\n 7         7\n 8         7\n 9        22\n10        18\n# ℹ 317 more rows\n\n$Benthos\n# A tibble: 1,594,662 × 1\n   abundance\n       <dbl>\n 1        18\n 2        36\n 3         2\n 4      1038\n 5       158\n 6       130\n 7        48\n 8        36\n 9        30\n10         6\n# ℹ 1,594,652 more rows\n\n$Birds\n# A tibble: 1,288,906 × 1\n   abundance\n       <dbl>\n 1       7.5\n 2       8  \n 3      12  \n 4       2.5\n 5       5  \n 6       7  \n 7      11  \n 8       2  \n 9      28  \n10       5  \n# ℹ 1,288,896 more rows\n\n$Fish\n# A tibble: 2,026,702 × 1\n   abundance\n       <dbl>\n 1         7\n 2         5\n 3         2\n 4         1\n 5         1\n 6         6\n 7         6\n 8        52\n 9        16\n10         1\n# ℹ 2,026,692 more rows\n\n$`Freshwater invertebrates`\n# A tibble: 91,528 × 1\n   abundance\n       <dbl>\n 1      2000\n 2     28000\n 3      8000\n 4     19000\n 5     11000\n 6    768000\n 7    156000\n 8     16000\n 9    194000\n10      9000\n# ℹ 91,518 more rows\n```\n:::\n:::\n\n\nUsing the base R approach, to sum up a column over lists, we would use something like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(select_abundance, function(x) { colSums (x)} )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$All\nabundance \n 10525821 \n\n$Amphibians\nabundance \n   115344 \n\n$Benthos\n  abundance \n23503327052 \n\n$Birds\nabundance \n 14673312 \n\n$Fish\nabundance \n 52881387 \n\n$`Freshwater invertebrates`\n abundance \n2898542291 \n\n$`Freshwater plants`\nabundance \n       NA \n\n$Mammals\nabundance \n 679713.1 \n\n$`Marine invertebrates`\nabundance \n256799039 \n\n$`Marine plants`\n  abundance \n25161115487 \n\n$Reptiles\nabundance \n    23555 \n\n$`Terrestrial invertebrates`\nabundance \n  1022759 \n\n$`Terrestrial plants`\nabundance \n  2427471 \n```\n:::\n:::\n\n\nWith `purrr`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect_abundance %>% \n  map(~ .x %>%  \n       summarise(row_sums = colSums(.)))\n```\n:::\n\n\nor\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect_abundance %>% \n  map(~summarise(., row_sums = colSums(.)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$All\n# A tibble: 1 × 1\n  row_sums\n     <dbl>\n1 10525821\n\n$Amphibians\n# A tibble: 1 × 1\n  row_sums\n     <dbl>\n1   115344\n\n$Benthos\n# A tibble: 1 × 1\n      row_sums\n         <dbl>\n1 23503327052.\n\n$Birds\n# A tibble: 1 × 1\n   row_sums\n      <dbl>\n1 14673312.\n\n$Fish\n# A tibble: 1 × 1\n   row_sums\n      <dbl>\n1 52881387.\n\n$`Freshwater invertebrates`\n# A tibble: 1 × 1\n     row_sums\n        <dbl>\n1 2898542291.\n\n$`Freshwater plants`\n# A tibble: 1 × 1\n  row_sums\n     <dbl>\n1       NA\n\n$Mammals\n# A tibble: 1 × 1\n  row_sums\n     <dbl>\n1  679713.\n\n$`Marine invertebrates`\n# A tibble: 1 × 1\n    row_sums\n       <dbl>\n1 256799039.\n\n$`Marine plants`\n# A tibble: 1 × 1\n      row_sums\n         <dbl>\n1 25161115487.\n\n$Reptiles\n# A tibble: 1 × 1\n  row_sums\n     <dbl>\n1    23555\n\n$`Terrestrial invertebrates`\n# A tibble: 1 × 1\n  row_sums\n     <dbl>\n1  1022759\n\n$`Terrestrial plants`\n# A tibble: 1 × 1\n  row_sums\n     <dbl>\n1 2427471.\n```\n:::\n:::\n\n\nWe filtered our data by `n_years > 10`, let's increase this number selecting only studies with more that 30 years of sampling.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbio_list <- split_taxa %>% map(~ .x %>%\n                      group_by(id) %>% \n                      mutate(nyear = n_distinct(year)) %>%\n                      filter(nyear > 30) %>% \n                      select(id:sp,-nyear))\n```\n:::\n\n\nNow we have some elements in our list with 0, meaning that there is no study with more than 30 years for that specific taxa. We can use either `discard()` or `keep()` to exclude or keep elements in our list, respectively. Let's exclude those elements without any data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiscard_elements <- bio_list %>% discard(., ~nrow(.) == 0)\n```\n:::\n\n\nNow, instead of 13 taxa we have seven.\n\nIf you want to exclude elements in a list by name, we can use `list_modify(\"listElementName\" = zap())`. Note that, previously, we could use `list_modify = \"NULL\"`, but this option is now deprecated. For example, let's exclude \"Benthos\" from our object\n\n\n::: {.cell}\n\n```{.r .cell-code}\nno_benthos <- discard_elements %>% \n  list_modify(\"Benthos\" = zap())\n```\n:::\n\n\nLet's create a more complex object now. As we have both abundance and biomass column, let's create a new column representing presence/absence (pres_ab). First, though, we have to deal with the NA's in our data. We can use `replace_na()` for that.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npresence_abs <- no_benthos %>% \n  map(~ .x %>%\n                      mutate(i = row_number()) %>% \n                      group_by(id) %>% \n                      replace_na(list(abundance = 0, biomass = 0)) %>% \n                      mutate(pres_ab = abundance+biomass,\n                             pres_ab = case_when(pres_ab > 0 ~ 1,\n                                   T ~ 0)))\n```\n:::\n\n\nHere I introduced a new (very useful) function `case_when()`. In the current example, I created the *\"pres_ab\"* column and asked the function to assign 1 (presence) case when the sum of abundance+biomass is higher than 0 and assign 0 when the opposite is true (`T ~ 0`) . You can use `case_when()` in many different ways, being very useful when we have to create new columns based on other columns or change values within columns.\n\nAs in the long format we don't have species assigned with 0 either in abundance or biomass, *\"pres_ab\"* column will be always 1 (my bad haha). Let's transform the data into the wide format to get presences and absences indeed. If we were not working with lists, we should transform each taxa separately. We can now combine `purrr` with `pivot_wider()` and transform all elements of our list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwide_list <- presence_abs %>% \n  map(~ .x %>%\n        group_by(id,year,sp) %>% \n        select(-plot,-abundance, -biomass) %>%\n        summarise(pres_ab = sum(pres_ab)) %>%\n        mutate(pres_ab = case_when(pres_ab > 0 ~ 1,\n                                   T ~ 0))%>% \n        ungroup %>% \n        arrange(sp) %>% # sp names in alphabetic order\n        pivot_wider(names_from = \"sp\", values_from = \"pres_ab\", \n                    values_fill = list(pres_ab=0)))\n```\n:::\n\n\nNow we have 0's and 1's. As we have species presences absences per year, we can check species gains and losses. For that we transform our data back into the long format (now with 0's and 1's) and use `case_when()` again to create the new column\n\nAs we are working with temporal data, we can use `case_when()` combined with `lag()` or `lead()` to analyse either the previous or next row in our data set, respectively. For example, let's create a new column to check species gains and losses per year.\n\nNow I will transform the lists into the long format again and check species gains and losses using `case_when()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_list <-wide_list %>% \n  map(~.x %>% \n        pivot_longer(-c(id,year),names_to = \"sp\", values_to = \"pres_ab\"))\n```\n:::\n\n\nNow we can check how each species is changing over time\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngain_loss <- long_list %>% \n  map(~.x %>% \n        group_by(id,sp) %>% \n        arrange(year, .by_group = TRUE)%>%\n    mutate(gain_loss = case_when(row_number() == 1 ~ \"NA\",\n                                 lag(pres_ab == 0) & pres_ab == 1  ~ \"gain\", \n                                 lag(pres_ab == 1) & pres_ab == 0 ~ \"loss\",\n                                 lag(pres_ab == 0) & pres_ab == 0  ~ \"persist_ab\",\n                         T ~ \"persist_pres\")))\n```\n:::\n\n\nHere I first grouped the data by study id and species, then I ordered the year, separately, by group. With `mutate()`, I created the column gain_loss, putting NA to the first year of each study, since we cant have gains or losses at the first year. Further, I assigned *gain* when the species was absent at the previous year (`lag(pres_ab==0)`) and present in the next one (`pres_ab==1`) and the opposite to *loss*. Also, if the species persisted absent or present, but we could also use \"NA\" if the idea is to check only gains and losses.\n\nAnother nice trick, when dealing with lists, is that sometimes we need to use the name of the elements in a list as a column. For example, here the name of the elements in our list is the taxa's name. We can use `imap` and `mutate` to create a new column based on these names. With `mutate` (in `dplyr 1.0.0`) we can also select the position of the new column with `.before` and `.after`, otherwise the new column will be the last one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntaxa_list <- gain_loss %>% imap(., ~mutate(.x, TAXA = .y, .after = year))\n```\n:::\n\n\n# Some other tricks with `purrr`\n\nSometimes, we have to deal with nested lists. I will not focus on nested lists here, but just out of curiosity, let's split our list once more, now based on the different studies we have. So we will have lists based on taxa and nested based on studies.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnest_list <- wide_list %>% \n  map(~split(.,.$id))\n```\n:::\n\n\nUsually, when I have such kind of data, I use nested `maps` - not sure if this is the most elegant approach though. For example, let's say we want to check the species richness for each taxa in each study based on years of sampling. I'd do something like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndouble_map <- nest_list %>% map(map, ~mutate(.,richness = rowSums(.[-1:-2]), .after = year))\n```\n:::\n\n\nTo work with two lists, we can use `map2()` . A simple example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist1<- as.list(c(a = 1, b = 2 ,c = 3))\n\nlist2<- as.list(c(a = 1, b = 2 ,c = 3))\n\nmap2(list1, list2, sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n[1] 2\n\n$b\n[1] 4\n\n$c\n[1] 6\n```\n:::\n:::\n\n\nI will use more `map2()` in the following posts, but this is particular interesting for those working with functional diversity of multiple taxa. You can do the same we did here (split the data by taxa), in both community and trait data, and then use `map2()` to calculate functional diversity. It will not work here of course, but something like this might work for you:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(FD)\nt1 <- map2(list_trait, list_comm, dbFD) # list with traits, list with communities and the function you want to apply (in this case, dbFD)\n```\n:::\n\n\nand then you can get the CWM, Rao or whatever metric you want from the `dbFD()` function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_CWM <- t1 %>% map(\"CWM\")\n\nlist_RaoQ <- t1 %>% map(\"RaoQ\") %>% \n  map(~ .x %>% as.data.frame())\n```\n:::\n\n\nAnother important trick we can do with `purrr` is to load multiple data into R. Sometimes we download ecological data and the `.csv` files come separated into multiple zip files. If you have faced that, and had to extract each file one by one, guess what? You can run them all at once with `purrr`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmanyfiles <- list.files(here(\"data\"), pattern = \"*.csv\", full.names = T) %>%\n        map_df(~vroom(.)) #here(\"data\"), as I explained at the beginning of this post, is where your files are located in your Rproject\n```\n:::\n\n\nIn summary, `tidyverse` has many functions that can boost our data analysis and how / when to use them will depend on your data and what you want to get from it. I hope to have kicked off some new useful functions and tricks.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}